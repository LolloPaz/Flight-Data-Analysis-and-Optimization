# -*- coding: utf-8 -*-
"""AA Group Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16s-tiJfxrOKMsFq0YZF233h5BV8K2FXw

# AA Group Project (Final Submission)

This project analyzes flight data from multiple sources with a strong focus on runtime optimizations. Visualizations include airport analytics, carrier rankings, a network graph of all airports and demos comparing the execution times of popular algorithms.

Group members:

- Messina Yara
- Monteleone Silvia
- Palleschi Riccardo
- Pazienza Lorenzo

# Data Loading and Parsing

- `parse_data_from_row(row, separator)`: Splits a row into a list of values, removing extra spaces and quotes.
- `load_airport_codes()`: Reads and parses airport data from multiple files, returning a dictionary of airport details.
- `load_flights(file_path)`: Reads and parses flight data from a file, returning a dictionary of flight details.
"""

# root_path = '/content/drive/MyDrive/data'
root_path = 'data/'


def load_airport_codes():
    airport_codes = {}
    with open(f'{root_path}/airport_codes.txt', 'r') as file:
        next(file)
        for row in file:
            data = parse_data_from_row(row, '\t')
            iata_code = data[3].upper()
            airport_codes[iata_code] = {
                'city': data[0],
                'state': data[1],
                'country': data[2],
            }
    with open(f'{root_path}/airports.dat.txt', 'r') as file:
        for row in file:
            data = parse_data_from_row(row, ',')
            iata_code = data[4].upper()
            if iata_code in airport_codes:
                airport_codes[iata_code]['lat'] = parse_float(data[6])
                airport_codes[iata_code]['lon'] = parse_float(data[7])
    with open(f'{root_path}/airports-code@public.csv', 'r') as file:
        next(file)
        for row in file:
            data = parse_data_from_row(row, ';')
            iata_code = data[0].upper()
            if iata_code in airport_codes:
                # prefer the coordinates from the airports.dat.txt file
                if 'lat' not in airport_codes[iata_code] or 'lon' not in airport_codes[iata_code]:
                    airport_codes[iata_code]['lat'] = parse_float(data[5])
                    airport_codes[iata_code]['lon'] = parse_float(data[6])
    return airport_codes


def load_flights(file_path):
    flights = {}
    with open(f'{root_path}/{file_path}', 'r') as file:
        next(file)
        for row in file:
            data = parse_data_from_row(row, '\t')
            flight_id = int(data[0])
            flights[flight_id] = {
                'year': data[1],
                'month': data[2],
                'day': data[3],
                'dep_time': data[4],
                'sched_dep_time': data[5],
                'dep_delay': parse_float(data[6]),
                'arr_time': data[7],
                'sched_arr_time': data[8],
                'arr_delay': parse_float(data[9]),
                'carrier': data[10],
                'flight': data[11],
                'tailnum': data[12],
                'origin': data[13],
                'dest': data[14],
                'air_time': data[15],
                'distance': parse_float(data[16]),
                'hour': data[17],
                'minute': data[18],
                'time_hour': data[19],
                'name': data[20],
            }
    return flights


def parse_float(value):
    try:
        return float(value)
    except ValueError:
        return 0.0


def parse_data_from_row(row, separator):
    return row.strip().replace('"', '').split(separator)

"""# Visualization: Global Flight Data

- `build_airport_stats()`: Calculates statistics for each airport, such as total flights, delays, and top carriers.
- `build_hover_text(code, info, stats)`: Creates hover text for airport markers with detailed stats.
- `build_marker_size(stats)`: Determines marker size based on flight volume.
- `build_marker_color(stats)`: Assigns marker color based on flight volume.
- `build_scatter_geo_markers()`: Prepares data for the scattergeo plot, including coordinates, hover text, and marker styles.

![](images/earth.png)

"""

from collections import defaultdict
import plotly.graph_objects as go


def build_airport_stats():
    stats = defaultdict(lambda: {
        'total_flights': 0,
        'departures': 0,
        'arrivals': 0,
        'total_dep_delay': 0.0,
        'total_arr_delay': 0.0,
        'avg_dep_delay': 0.0,
        'avg_arr_delay': 0.0,
        'carrier_flights': defaultdict(int),
        'top_carrier': ('N/A', 0)
    })
    for _, flight in flights.items():
        origin = flight['origin']
        dest = flight['dest']
        carrier = flight['carrier']
        dep_delay = flight['dep_delay']
        arr_delay = flight['arr_delay']

        # update departure airport stats
        stats[origin]['departures'] += 1
        stats[origin]['total_dep_delay'] += dep_delay
        stats[origin]['avg_dep_delay'] = stats[origin]['total_dep_delay'] / \
            stats[origin]['departures']
        stats[origin]['carrier_flights'][carrier] += 1
        if stats[origin]['carrier_flights'][carrier] > stats[origin]['top_carrier'][1]:
            stats[origin]['top_carrier'] = (
                carrier, stats[origin]['carrier_flights'][carrier])

        # update arrival airport stats
        stats[dest]['arrivals'] += 1
        stats[dest]['total_arr_delay'] += arr_delay
        stats[dest]['avg_arr_delay'] = stats[dest]['total_arr_delay'] / \
            stats[dest]['arrivals']
        stats[dest]['carrier_flights'][carrier] += 1
        if stats[dest]['carrier_flights'][carrier] > stats[dest]['top_carrier'][1]:
            stats[dest]['top_carrier'] = (
                carrier, stats[dest]['carrier_flights'][carrier])

        stats[origin]['total_flights'] = stats[origin]['departures'] + \
            stats[origin]['arrivals']
        stats[dest]['total_flights'] = stats[dest]['departures'] + \
            stats[dest]['arrivals']

    return stats


def build_hover_text(code, info, stats):
    return (
        f"<b>{code}</b> - {info['city']}, {info['country']}"
        f"<br><br>"
        f"<b>Flight Statistics:</b>"
        f"<br>• Total flights: <b>{stats['total_flights']:,}</b>"
        f"<br>• Departures: <b>{stats['departures']:,}</b>"
        f"<br>• Arrivals: <b>{stats['arrivals']:,}</b>"
        f"<br><br>"
        f"<b>Top Carrier:</b>"
        f"<br>• {stats['top_carrier'][0]}: <b>{stats['top_carrier'][1]:,}</b> flights"
        f"<br><br>"
        f"<b>Delays (average):</b>"
        f"<br>• Departure: <b>{stats['avg_dep_delay']:.1f}</b> min"
        f"<br>• Arrival: <b>{stats['avg_arr_delay']:.1f}</b> min"
    )


def build_marker_size(stats):
    min_size = 5
    max_size = 25
    scale = 300
    return min(max_size, max(min_size, int(stats['total_flights'] / len(flights) * scale)))


def build_marker_color(stats):
    intensity = stats['total_flights'] / len(flights)

    r = int(51 + (195 - 51) * intensity)
    g = int(89 * (1 - intensity))
    b = int(127 * (1 - intensity))

    return f'rgb({r}, {g}, {b})'


def build_scatter_geo_markers():
    lats, lons, hover_texts, sizes, colors = [], [], [], [], []
    for code, info in airport_codes.items():
        if 'lat' not in info or 'lon' not in info:
            print(f"Missing coordinates for {code}")
            continue
        lats.append(info['lat'])
        lons.append(info['lon'])
        stats = airport_stats[code]
        hover_texts.append(build_hover_text(code, info, stats))
        sizes.append(build_marker_size(stats))
        colors.append(build_marker_color(stats))
    return dict(
        lat=lats,
        lon=lons,
        hovertext=hover_texts,
        marker=dict(size=sizes, color=colors, opacity=0.8),
    )


airport_codes = load_airport_codes()
flights = load_flights('flights_large.txt')
airport_stats = build_airport_stats()

earth = go.Figure()
airports = go.Scattergeo(
    mode="markers",
    textposition="top center",
    **build_scatter_geo_markers(),
)
earth.add_trace(airports)
earth.update_geos(
    projection_type="orthographic",
    showocean=True,
    oceancolor="lightblue",
    showcountries=True,
    countrycolor="black",
)
earth.update_layout(
    title={
        'text': f"Tracking {len(flights):,} Flights Across {len(airport_codes)} Airports",
        'font': dict(size=22),
    },
)
earth.show()

"""# Visualization: Sorting Algorithms Race

- `quicksort(items)`: A recursive quicksort implementation.
- `insertion_sort(items)`: An insertion sort implementation.
- `bubble_sort(items)`: A bubble sort implementation.

![](images/sorting.png)

"""

from time import time
import plotly.graph_objects as go
import signal


def quicksort(items):
    if len(items) <= 1:
        return items
    pivot = items[len(items) // 2]
    left = []
    middle = []
    right = []
    for x in items:
        if x < pivot:
            left.append(x)
        if x == pivot:
            middle.append(x)
        if x > pivot:
            right.append(x)
    return quicksort(left) + middle + quicksort(right)


def insertion_sort(items):
    for i in range(1, len(items)):
        key = items[i]
        j = i - 1
        while j >= 0 and items[j] > key:
            items[j + 1] = items[j]
            j -= 1
        items[j + 1] = key
    return items


def bubble_sort(items):
    n = len(items)
    for i in range(n):
        for j in range(0, n - i - 1):
            if items[j] > items[j + 1]:
                items[j], items[j + 1] = items[j + 1], items[j]
    return items


def timeout_handler():
    raise Exception()


def get_sort_times(sort_func, datasets, timeout_sec=120):
    times = []
    for dataset in datasets:
        # quick timeout hack for demonstration purposes
        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(timeout_sec)
        try:
            start_time = time()
            sort_func(list(dataset.keys()))
            end_time = time()
            times.append(end_time - start_time)
        except Exception:
            times.append(timeout_sec)
            print(f"{sort_func.__name__} timed out after {timeout_sec} seconds.")
        finally:
            signal.alarm(0)
    return times


datasets = [load_flights('flights_small.txt'),
            load_flights('flights_medium.txt'),
            load_flights('flights_large.txt')]
x = ['Small (50k)', 'Medium (100k)', 'Large (~300k)']
bubble_sort_times = get_sort_times(bubble_sort, datasets)
insertion_sort_times = get_sort_times(insertion_sort, datasets)
quicksort_times = get_sort_times(quicksort, datasets)

fig = go.Figure()
fig.add_trace(go.Bar(
    name='Bubble Sort',
    x=x,
    y=bubble_sort_times,
    text=[f'{t:.2f}s' for t in bubble_sort_times],
    textposition='auto',
    marker_color='#FF5733',
    hovertemplate=f'Bubble Sort<br>%{{x}} Dataset: %{{y:.3f}} seconds'
))
fig.add_trace(go.Bar(
    name='Insertion Sort',
    x=x,
    y=insertion_sort_times,
    text=[f'{t:.2f}s' for t in insertion_sort_times],
    textposition='auto',
    marker_color='#33FF57',
    hovertemplate=f'Insertion Sort<br>%{{x}} Dataset: %{{y:.3f}} seconds'
))
fig.add_trace(go.Bar(
    name='Quick Sort',
    x=x,
    y=quicksort_times,
    text=[f'{t:.2f}s' for t in quicksort_times],
    textposition='auto',
    marker_color='#3357FF',
    hovertemplate=f'Quick Sort<br>%{{x}} Dataset: %{{y:.3f}} seconds'
))
fig.update_layout(
    title={
        'text': 'Sorting Algorithm Race (120 seconds timeout)',
        'font': {'size': 24, 'color': '#333'},
        'y': 0.95
    },
    xaxis_title={
        'text': 'Dataset Size',
        'font': {'size': 16, 'color': '#333'}
    },
    yaxis_title={
        'text': 'Execution Time (seconds)',
        'font': {'size': 16, 'color': '#333'}
    },
    barmode='group',
    plot_bgcolor='white',
    height=600,
    width=1000,
    showlegend=True,
    legend={
        'title': {'text': 'Algorithms'},
        'bgcolor': 'rgba(255,255,255,0.8)',
        'bordercolor': '#333',
        'borderwidth': 1
    }
)
fig.update_yaxes(
    showgrid=True,
    gridwidth=1,
    gridcolor='#E5E5E5'
)
fig.show()

"""# Visualization: Lookup Execution Times

- `binary_search`: Finds elements in a sorted list with O(log n) complexity.
- `linear_search`: Sequentially checks elements with O(n) complexity, less efficient for large datasets.
- `BST find()`: Searches for a node in a binary search tree, typically O(log n) for balanced trees.
- `Dictionary lookup`: Uses a hash table for O(1) average-case lookup time.

![](images/lookup.png)

"""

from time import time
import plotly.graph_objects as go


class FlightNode:
    def __init__(self, flight_id, flight_data):
        self.flight_id = flight_id
        self.flight_data = flight_data
        self.left = None
        self.right = None
        self.height = 1


class FlightBST:
    def __init__(self):
        self.root = None

    def insert(self, flight_id, flight_data):
        node = FlightNode(flight_id, flight_data)
        if not self.root:
            self.root = node
            return
        current = self.root
        while current:
            if flight_id <= current.flight_id:
                if current.left:
                    current = current.left
                else:
                    current.left = node
                    return
            else:
                if current.right:
                    current = current.right
                else:
                    current.right = node
                    return

    def find(self, flight_id):
        current = self.root
        while current:
            if flight_id == current.flight_id:
                return current.flight_data
            elif flight_id < current.flight_id:
                current = current.left
            else:
                current = current.right
        return None

    def inorder_traversal(self, node, result=None):
        # initialize result list if not provided,
        # if result were initialized as [] it would be created when the function is defined
        # leading to unintended side effects
        if result is None:
            result = []
        if node:
            self.inorder_traversal(node.left, result)
            result.append((node.flight_id, node.flight_data))
            self.inorder_traversal(node.right, result)
        return result


def binary_search(flights, target):
    left = 0
    right = len(flights) - 1

    while left <= right:
        mid = (left + right) // 2
        if flights[mid] == target:
            return True
        elif flights[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return False


def linear_search(flights, target):
    for i in range(len(flights)):
        if flights[i] == target:
            return True
    return False


def get_search_time(search_func):
    start_time = time()
    search_func()
    end_time = time()
    return end_time - start_time


flights = load_flights('flights_medium.txt')
flight_tree = FlightBST()
for flight_id, flight_data in flights.items():
    flight_tree.insert(flight_id, flight_data)

target_flight = 245595
flight_keys = list(flights.keys())
sorted_flights = sorted(flight_keys)
binary_search_time = get_search_time(
    lambda: binary_search(sorted_flights, target_flight)
)
linear_search_time = get_search_time(
    lambda: linear_search(flight_keys, target_flight)
)
bst_find_time = get_search_time(
    lambda: flight_tree.find(target_flight)
)
dict_lookup_time = get_search_time(
    lambda: flights.get(target_flight)
)
fig = go.Figure(go.Bar(
    x=['Binary Search (sorted)',
       'Linear Search',
       'BST Find',
       'Dictionary Lookup'],
    y=[binary_search_time, linear_search_time, bst_find_time, dict_lookup_time],
    text=[f'{time:.6f} sec' for time in [
        binary_search_time,
        linear_search_time,
        bst_find_time,
        dict_lookup_time
    ]],
    textposition='auto',
    marker_color=['#FF5733', '#33FF57', '#3357FF', '#FF33A1'],
))
fig.update_layout(
    title='Lookup Execution Times (100k flights)',
    xaxis_title='Search Algorithm',
    yaxis_title='Execution Time (seconds)',
    height=500,
    width=800
)
fig.show()

"""# Bonus Visualization: BST vs AVL Tree Node Depth Distribution

- `FlightNode`: Represents a single node with flight info and child references.
- `FlightBST`: A BST implementation.
- `FlightAVL`: An AVL tree implementation with balancing logic.

![](images/trees.png)

"""

import plotly.graph_objects as go
from collections import defaultdict


class FlightAVLTree:
    def __init__(self):
        self.root = None

    def insert(self, flight_id, flight_data):
        def _insert(node, flight_id, flight_data):
            if not node:
                return FlightNode(flight_id, flight_data)

            if flight_id <= node.flight_id:
                node.left = _insert(node.left, flight_id, flight_data)
            elif flight_id > node.flight_id:
                node.right = _insert(node.right, flight_id, flight_data)

            node.height = 1 + max(self._get_height(node.left),
                                  self._get_height(node.right))
            balance = self._get_balance(node)
            if balance > 1 and flight_id < node.left.flight_id:
                return self._right_rotate(node)
            if balance < -1 and flight_id > node.right.flight_id:
                return self._left_rotate(node)
            if balance > 1 and flight_id > node.left.flight_id:
                node.left = self._left_rotate(node.left)
                return self._right_rotate(node)
            if balance < -1 and flight_id < node.right.flight_id:
                node.right = self._right_rotate(node.right)
                return self._left_rotate(node)
            return node

        self.root = _insert(self.root, flight_id, flight_data)

    def find(self, flight_id):
        def _find(node, flight_id):
            if not node:
                return None
            if flight_id == node.flight_id:
                return node.flight_data
            elif flight_id < node.flight_id:
                return _find(node.left, flight_id)
            else:
                return _find(node.right, flight_id)

        return _find(self.root, flight_id)

    def inorder_traversal(self, node, result=None):
        if result is None:
            result = []
        if node:
            self.inorder_traversal(node.left, result)
            result.append((node.flight_id, node.flight_data))
            self.inorder_traversal(node.right, result)
        return result

    def _left_rotate(self, z):
        y = z.right
        T2 = y.left

        y.left = z
        z.right = T2

        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))

        return y

    def _right_rotate(self, z):
        y = z.left
        T3 = y.right

        y.right = z
        z.left = T3

        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))

        return y

    def _get_height(self, node):
        if not node:
            return 0
        return node.height

    def _get_balance(self, node):
        if not node:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)


def calculate_node_depths(node, depth=0, depth_counts=None):
    if depth_counts is None:
        depth_counts = defaultdict(int)
    if node:
        depth_counts[depth] += 1
        calculate_node_depths(node.left, depth + 1, depth_counts)
        calculate_node_depths(node.right, depth + 1, depth_counts)
    return depth_counts


# BST takes too long to load flights_large.txt (tree is unbalanced)
flights = load_flights('flights_medium.txt')
flight_bst = FlightBST()
flight_avl_tree = FlightAVLTree()

for flight_id, flight_data in flights.items():
    flight_bst.insert(flight_id, flight_data)
    flight_avl_tree.insert(flight_id, flight_data)

bst_depths = calculate_node_depths(flight_bst.root)
avl_depths = calculate_node_depths(flight_avl_tree.root)

fig = go.Figure()
fig.add_trace(go.Bar(
    x=list(bst_depths.keys()),
    y=list(bst_depths.values()),
    name="BST Node Depths",
    marker_color="blue"
))
fig.add_trace(go.Bar(
    x=list(avl_depths.keys()),
    y=list(avl_depths.values()),
    name="AVL Node Depths",
    marker_color="green"
))
fig.update_layout(
    title="Node Depth Distribution: BST vs AVL Tree (100k flights)",
    xaxis_title="Depth",
    yaxis_title="Number of Nodes",
    barmode="group",
    height=500,
    width=800
)
fig.show()

"""# Visualization: Carrier Rankings

Compare and rank carriers based on performance metrics.

- Total flights
- Average departure delay
- Average arrival delay
- Total distance

![](images/carriers.png)

"""

import plotly.graph_objects as go
from collections import defaultdict

flights = load_flights('flights_large.txt')


def quicksort_v2(items, key=lambda x: x):
    # quicksort implementation with a custom key function
    if len(items) <= 1:
        return items
    pivot = items[len(items) // 2]
    left = []
    middle = []
    right = []
    for x in items:
        if key(x) < key(pivot):
            left.append(x)
        elif key(x) == key(pivot):
            middle.append(x)
        else:
            right.append(x)
    return quicksort_v2(left, key) + middle + quicksort_v2(right, key)


carrier_stats = defaultdict(lambda: {
    'total_flights': 0,
    'total_dep_delay': 0.0,
    'total_arr_delay': 0.0,
    'avg_dep_delay': 0.0,
    'avg_arr_delay': 0.0,
    'total_distance': 0,
    'carrier_name': None
})

for flight in flights.values():
    carrier = flight['carrier']
    carrier_stats[carrier]['total_flights'] += 1
    carrier_stats[carrier]['total_dep_delay'] += flight['dep_delay']
    carrier_stats[carrier]['total_arr_delay'] += flight['arr_delay']
    carrier_stats[carrier]['avg_dep_delay'] = carrier_stats[carrier]['total_dep_delay'] / \
        carrier_stats[carrier]['total_flights']
    carrier_stats[carrier]['avg_arr_delay'] = carrier_stats[carrier]['total_arr_delay'] / \
        carrier_stats[carrier]['total_flights']
    carrier_stats[carrier]['total_distance'] += flight['distance']
    carrier_stats[carrier]['carrier_name'] = flight['name']


total_flights = quicksort_v2(
    list(carrier_stats.items()), key=lambda x: x[1]['total_flights'])
total_distance = quicksort_v2(
    list(carrier_stats.items()), key=lambda x: x[1]['total_distance'])
avg_dep_delay = quicksort_v2(
    list(carrier_stats.items()), key=lambda x: x[1]['avg_dep_delay'])
avg_arr_delay = quicksort_v2(
    list(carrier_stats.items()), key=lambda x: x[1]['avg_arr_delay'])

buttons = []
buttons.append(dict(
    label='Total Flights',
    method="update",
    args=[{"visible": [True, False, False, False]}]
))
buttons.append(dict(
    label='Total Distance (Kilometers)',
    method="update",
    args=[{"visible": [False, True, False, False]}]
))
buttons.append(dict(
    label='Average Departure Delay (minutes)',
    method="update",
    args=[{"visible": [False, False, True, False]}]
))
buttons.append(dict(
    label='Average Arrival Delay (minutes)',
    method="update",
    args=[{"visible": [False, False, False, True]}]
))

fig = go.Figure()
fig.add_trace(go.Bar(
    name='Total Flights',
    x=[x[0] for x in total_flights],
    y=[x[1]['total_flights'] for x in total_flights],
    visible=True,
    hovertemplate='%{x}: %{y}<br>%{customdata}<extra></extra>',
    customdata=[x[1]['carrier_name'] for x in total_flights]
))
fig.add_trace(go.Bar(
    name='Total Distance (Kilometers)',
    x=[x[0] for x in total_distance],
    y=[x[1]['total_distance'] for x in total_distance],
    visible=False,
    hovertemplate='%{x}: %{y}<br>%{customdata}<extra></extra>',
    customdata=[x[1]['carrier_name'] for x in total_distance]
))
fig.add_trace(go.Bar(
    name='Average Departure Delay (minutes)',
    x=[x[0] for x in avg_dep_delay],
    y=[x[1]['avg_dep_delay'] for x in avg_dep_delay],
    visible=False,
    hovertemplate='%{x}: %{y:.1f} min<br>%{customdata}<extra></extra>',
    customdata=[x[1]['carrier_name'] for x in avg_dep_delay]
))
fig.add_trace(go.Bar(
    name='Average Arrival Delay (minutes)',
    x=[x[0] for x in avg_arr_delay],
    y=[x[1]['avg_arr_delay'] for x in avg_arr_delay],
    visible=False,
    hovertemplate='%{x}: %{y:.1f} min<br>%{customdata}<extra></extra>',
    customdata=[x[1]['carrier_name'] for x in avg_arr_delay]
))
fig.update_layout(
    updatemenus=[{
        'buttons': buttons,
        'direction': "down",
        'showactive': True,
        'x': 1,
        'y': 1.15,
    }],
    title="Carrier Statistics (~300k flights)",
    xaxis_title="Carrier",
    height=600,
    width=1000
)
fig.show()

"""# Visualization: Airport Network Graph

Displays the global airport network as a graph where each node represents an airport and each edge represents a direct flight connection. Edge thickness shows the number of flights between airports while edge color reflects the average delay on that route (blue = low delay, yellow = high delay).

![](images/graph.png)

"""

import networkx
import plotly.graph_objects as go

graph = networkx.Graph()
flights = load_flights('flights_large.txt')

edge_weights = {}
edge_delays = {}

for _, flight in flights.items():
    origin = flight['origin']
    dest = flight['dest']

    # sort the edge to avoid duplicates
    key = tuple(sorted((origin, dest)))
    edge_weights[key] = edge_weights.get(key, 0) + 1

    arr_delay = flight['arr_delay']
    dep_delay = flight['dep_delay']
    if key not in edge_delays:
        edge_delays[key] = {'total_delay': 0.0, 'count': 0}
    edge_delays[key]['total_delay'] += arr_delay + dep_delay
    edge_delays[key]['count'] += 1

    graph.add_edge(origin, dest)

graph = graph.to_undirected()

# visual arrangement of the graph using the Fruchterman-Reingold force-directed algorithm
layout = networkx.spring_layout(graph)

# normalize edge weights
min_width = 0.5
max_width = 8
weights = list(edge_weights.values())
min_weight = min(weights)
max_weight = max(weights)

avg_delays = {k: v['total_delay'] / v['count'] for k, v in edge_delays.items()}
delay_values = list(avg_delays.values())
min_delay = min(delay_values)
max_delay = max(delay_values)


def get_edge_width(weight):
    # linear scaling between min_width and max_width
    return min_width + (weight - min_weight) / (max_weight - min_weight) * (max_width - min_width)


def get_edge_color(avg_delay):
    # linear interpolation between blue (low delay) and yellow (high delay)
    ratio = (avg_delay - min_delay) / (max_delay - min_delay)
    r = int(46 + (255 - 46) * ratio)
    g = int(134 + (221 - 134) * ratio)
    b = int(222 + (51 - 222) * ratio)
    return f'rgb({r},{g},{b})'


# draw edges with colors and widths based on average delay and weight
edge_traces = []
for edge in graph.edges():
    key = tuple(sorted(edge))
    x0, y0 = layout[edge[0]]
    x1, y1 = layout[edge[1]]
    width = get_edge_width(edge_weights.get(key, 1))
    avg_delay = avg_delays.get(key, 0)
    color = get_edge_color(avg_delay)
    edge_traces.append(
        go.Scatter(
            x=[x0, x1],
            y=[y0, y1],
            line=dict(width=width, color=color),
            showlegend=False
        )
    )

# collect node positions for the scatter plot
node_x = []
node_y = []
for node in graph.nodes():
    x, y = layout[node]
    node_x.append(x)
    node_y.append(y)

legend_traces = [
    go.Scatter(x=[None, None], y=[None, None], mode='lines',
               line=dict(color='rgb(46,134,222)', width=4),
               name='Low Delay (Blue)', showlegend=True),
    go.Scatter(x=[None, None], y=[None, None], mode='lines',
               line=dict(color='rgb(255,221,51)', width=4),
               name='High Delay (Yellow)', showlegend=True),
    go.Scatter(x=[None, None], y=[None, None], mode='lines',
               line=dict(color='gray', width=8),
               name='Many Flights (Thick)', showlegend=True),
    go.Scatter(x=[None, None], y=[None, None], mode='lines',
               line=dict(color='gray', width=1),
               name='Few Flights (Thin)', showlegend=True),
]

fig = go.Figure(
    data=legend_traces + edge_traces + [
        go.Scatter(
            x=node_x, y=node_y,
            mode='markers',
            hoverinfo='text',
            marker=dict(
                color=[graph.degree(n) for n in graph.nodes()],
                size=8,
                colorbar=dict(
                    title='Connections',
                    xanchor='left',
                    x=-0.10,
                    y=0.20,
                ),
            ),
            text=[str(n) for n in graph.nodes()],
            showlegend=False,
        )
    ],
    layout=go.Layout(
        title='Airport Network Graph (~300k flights)',
        legend=dict(
            x=-0.10,
            y=1,
            bordercolor='#333',
            borderwidth=1,
        ),
        margin=dict(b=20, l=5, r=5, t=40),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        plot_bgcolor='#F5F5F5',
        paper_bgcolor='#F5F5F5',
    )
)
fig.show()

"""# Visualization: BFS vs DFS

The difference between Breadth-First Search (BFS) and Depth-First Search (DFS) traversals on the airport network graph where only the nodes and edges visited during the traversal are shown.

![](images/bfs.png)
![](images/dfs.png)

"""

import networkx
import plotly.graph_objects as go

graph = networkx.Graph()
flights = load_flights('flights_large.txt')

for _, flight in flights.items():
    origin = flight['origin']
    dest = flight['dest']
    key = tuple(sorted((origin, dest)))
    graph.add_edge(origin, dest)

graph = graph.to_undirected()


def bfs(start):
    visited = set()
    queue = [start]
    order = []
    while queue:
        node = queue.pop(0)
        if node not in visited:
            visited.add(node)
            order.append(node)
            queue.extend(n for n in graph.neighbors(node) if n not in visited)
    return order


def dfs(start):
    visited = set()
    stack = [start]
    order = []
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            order.append(node)
            stack.extend(n for n in graph.neighbors(node) if n not in visited)
    return order


def visualize_traversal(traversal_order, title):
    subgraph = graph.subgraph(traversal_order)
    layout = networkx.spring_layout(subgraph, seed=1)
    node_x = []
    node_y = []
    node_text = []
    for idx, node in enumerate(traversal_order):
        x, y = layout[node]
        node_x.append(x)
        node_y.append(y)
        node_text.append(f"Step {idx+1}: {node}")

    edge_traces = []
    for edge in subgraph.edges():
        x0, y0 = layout[edge[0]]
        x1, y1 = layout[edge[1]]
        edge_traces.append(
            go.Scatter(
                x=[x0, x1],
                y=[y0, y1],
                mode='lines',
                line=dict(color='gray', width=1),
                showlegend=False
            )
        )

    fig = go.Figure(
        data=edge_traces + [
            go.Scatter(
                x=node_x,
                y=node_y,
                mode='markers+text',
                text=node_text,
                textposition='top center',
                marker=dict(size=14, color='royalblue'),
                showlegend=False
            )
        ],
        layout=go.Layout(
            title=title,
            showlegend=False,
            margin=dict(b=20, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            plot_bgcolor='#F5F5F5',
            paper_bgcolor='#F5F5F5',
        )
    )
    fig.show()


bfs_order = bfs('JFK')
dfs_order = dfs('JFK')
visualize_traversal(bfs_order[:10], 'BFS Traversal (First 10 Steps)')
visualize_traversal(dfs_order[:10], 'DFS Traversal (First 10 Steps)')